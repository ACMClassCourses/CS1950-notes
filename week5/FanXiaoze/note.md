## 排序

基于比较的排序算法的时间复杂度下限是 $O(n\log n)$ 的。证明：

> 需要用到**决策树模型**，该树的每个叶子节点是一种排序结果，决策树的每个内部节点表示一个比较操作，显然 $m$ 个叶子节点的决策树高度至少为 $\log_2(m)$。而排序结果数量是 $O(n!)$ ，故复杂度下界 $O(\log_2(n!))=O(n\log n)$

### 选择排序 & 插入排序

都将待排序序列分为已排序和未排序两部分，不同在于：

- 选择排序每次从未排序部分中选择最小（或最大）的元素，并将其放到已排序部分的末尾

- 插入排序每次从未排序部分中选择一个元素，并插入到已排序部分的适当位置，使得已排序部分仍然有序。

### 基数排序

是一种不基于比较的排序算法。将待排序的元素按照**低位到高位**的顺序依次进行排序，直到最高位完成排序为止。

1. 确定将要排序的元素的最大位数（或最大数值），以确定需要进行多少轮排序。
2. 从最低位开始，根据当前位数将待排序的元素分组。
3. 对每组内的元素按照当前位数进行**稳定**的排序，可以使用[计数排序](https://oi-wiki.org/basic/counting-sort/)等方法进行排序。
4. 重复第2步和第3步，直到对所有位数都进行了排序。
5. 最后得到的排序结果即为最终的有序序列。

时间复杂度 $O(kn)$ 空间复杂度 $O(n+k)$  （每个元素的位数为 $k$ ）



## 查找

### 顺序查找

按顺序逐一比对。复杂度 $O(n)$

### 二分查找

需要数据有序，先有一个查找的范围 $[L,R]$ ，每次取 $M=\frac{L+R}{2}$，取 $M$ 处的元素与目标元素比对，缩小查找访问到 $[L,M-1]$ 或 $[M+1,R]$ 或找到目标元素退出。复杂度 $O(\log n)$



## 密码学先导

### 对称加密

加密和解密用的是同一个密钥。那在分发密钥是一个难题，要担心泄露。

### 非对称加密

密钥分为公钥（Public Key）和私钥（Private Key）。在非对称加密中，公钥用于加密数据，而私钥用于解密数据。公钥可以自由分发给其他人，而私钥必须保密。要将消息加密，使用接收者的公钥对消息进行加密操作，只有持有私钥的接收者才能解密该消息。

其中一种比较常用的算法 [RSA](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)
